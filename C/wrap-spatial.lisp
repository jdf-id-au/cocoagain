(ql:quickload :cl-ppcre)

;;(directory "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/Spatial/*.h")

;; FIXME 2025-09-14 11:46:09 over-matching; something to do with escaping?
;; ... better done with libclang...
;; (let* ((re (ppcre:create-scanner "^(SP[A-Z][a-z]\\S*|void) SP[A-Z][a-z]\\S*\\(.*\\)"
;;                                  :single-line-mode t
;;                                  :multi-line-mode t)))

;;   (ppcre:all-matches-as-strings
;;    re
;;    (uiop:read-file-string #P"/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/Spatial/SPAffineTransform3D.h")))

(defconstant +omit-fns+
  ;; Derived from compiler feedback on earlier wrap_spatial.m versions
  '(("SPAffineTransform3D" "SPAffineTransform3DMakeTranslation" (("SPSize3D" "translation")))
    ("SPAffineTransform3D" "SPAffineTransform3DMakeWithProjective" (("SPProjectiveTransform3D" "transform")))
    ("SPPoint3D" "SPPoint3DGetOrigin" (("SPPoint3D" "point")))
    ("SPPoint3D" "SPPoint3DMakeWithVector" (("simd_double3" "xyz")))
    ("SPPoint3D" "SPPoint3DTranslate" (("SPPoint3D" "point") ("SPSize3D" "offset")))
    ("SPPose3D" "SPPose3DTranslate" (("SPPose3D" "pose") ("SPSize3D" "offset")))
    ("SPProjectiveTransform3D" "SPProjectiveTransform3DMakeTranslation" (("SPSize3D" "translation")))
    ("SPRect3D" "SPRect3DTranslate" (("SPRect3D" "rect") ("SPSize3D" "offset")))
    ("SPRotation3D" "SPPoint3DRotationToPoint" (("SPPoint3D" "point") ("SPPoint3D" "other")))
    ("SPRotation3D" "SPRect3DRotationToRect" (("SPRect3D" "rect") ("SPRect3D" "other")))
    ("SPRotation3D" "SPRotation3DMake" (("SPRotationAxis3D" "axis") ("SPAngle" "angle")))
    ("SPRotation3D" "SPRotation3DMakeLookAt" (("SPPoint3D" "position") ("SPPoint3D" "target") ("SPVector3D" "up")))
    ("SPRotation3D" "SPRotation3DMakeLookAt" (("SPPoint3D" "target") ("SPVector3D" "up")))
    ("SPRotationAxis3D" "SPRotationAxis3DMakeWithVector" (("simd_double3" "xyz")))
    ("SPScaledPose3D" "SPScaledPose3DConcatenation" (("SPPose3D" "lhs") ("SPScaledPose3D" "rhs")))
    ("SPScaledPose3D" "SPScaledPose3DConcatenation" (("SPScaledPose3D" "lhs") ("SPPose3D" "rhs")))
    ("SPSize3D" "SPSize3DMakeWithVector" (("simd_double3" "xyz")))
    ("SPSphericalCoordinates3D" "SPSphericalCoordinates3DMakeWithCartesianVector" (("simd_double3" "xyz")))
    ("SPVector3D" "SPAffineTransform3DGetOffset" (("SPAffineTransform3D" "transform")))
    ("SPVector3D" "SPProjectiveTransform3DGetOffset" (("SPProjectiveTransform3D" "transform")))
    ("void" "SPAffineTransform3DSetOffset" (("SPAffineTransform3D" "*transform") ("SPVector3D" "offset")))
    ("void" "SPProjectiveTransform3DSetOffset" (("SPProjectiveTransform3D" "*transform") ("SPVector3D" "offset")))
    ("SPRay3D" "SPRay3DTranslate" (("SPRay3D" "ray") ("SPSize3D" "offset")))))
    
(defun omitp (fn-desc)
  (if (find fn-desc +omit-fns+ :test 'equal) t nil))

(defun parse-params (paramstr)
  (loop for param in (ppcre:split ",\\s*" paramstr)
        collect (ppcre:split"\\s+" param)))

(defun parse-fn (fnstr)
  (ppcre:register-groups-bind (ret-type fn-name params)
      ("(SP[A-Z][a-z]\\S*|void) (SP[A-Z][a-z]\\S*)\\((.*)\\)" fnstr)
    (list ret-type fn-name (parse-params params))))

(defun parse-file (fname)
  (with-open-file (stream fname :direction :input)
    (loop for line = (read-line stream nil :eof)
          until (eq line :eof)
          for ln = (parse-fn line)
          unless (omitp ln)
          collect ln)))

(defun wrap-params (paramlist)
  (let* ((o (make-string-output-stream))
         (firstp t))
    (loop for (ty param) in paramlist
          do (format o "~a~a ~a"
                     (if firstp (progn (setf firstp nil) "") ", ")
                     ty param))
    (get-output-stream-string o)))

(defun pointer-passthrough (param)
  (ppcre:register-groups-bind
      (star name brack)
      ("(\\*)?([^\\[\\]]*)(\\[\\])?" param)
    (values name (if (or star brack) t))))

(defun wrap-args (paramlist)
  (let* ((o (make-string-output-stream)))
    (destructuring-bind (ty param) (car paramlist)
      (format o "~a" (pointer-passthrough param)))
    (loop for (ty param) in (cdr paramlist)
          do (format o ", ~a" (pointer-passthrough param)))
    (get-output-stream-string o)))

(defun wrap-fns (fns to-stream)
  "Wrap extracted functions in spatial_fns.txt, for writing to target .m
file which will need some massaging in response to compiler messages."
  (format to-stream "// Autogenerated~%#include <Spatial/Spatial.h>~%")
  (loop for (ret-type fn-name params) in fns
        do (format to-stream "~a wrap~a(~a) {~a~a(~a);}~%"
                   ret-type
                   fn-name
                   (wrap-params params)
                   (if (string= ret-type "void") "" "return ")
                   fn-name
                   (wrap-args params))))

(defun all-types (parsed)
  (sort
   (delete-duplicates
    (loop for (ret-type nil params) in parsed
          nconc (cons ret-type (loop for (ty nil) in params collect ty)))
    :test 'equal)
   #'string-lessp))

(defvar types ;; target types from spatial.lisp bidi-ffi calls
  '(("double" . :double)
    ("int" . :int)
    ("simd_double3" . v3)
    ("simd_double4x3" . m43)
    ("simd_double4x4" . m44)
    ("simd_quatd" . v4)
    ("SPAffineTransform3D" . m43)
    ("SPAngle" . angle)
    ("SPEulerAngles" . euler-angles)
    ("SPEulerAngleOrder" . :uint32)
    ("SPPoint3D" . point)
    ("SPPose3D" . pose)
    ("SPProjectiveTransform3D" . m44)
    ("SPRay3D" . ray)
    ("SPRect3D" . rect)
    ("SPRotation3D" . rotation)
    ("SPRotationAxis3D" . rotation-axis)
    ("SPScaledPose3D" . scaled-pose)
    ("SPSize3D" . size)
    ("SPSphericalCoordinates3D" . spherical)
    ("SPVector3D" . vec)))

(defun convert-type (param)
  (destructuring-bind (ty p) param
    (let ((rt (or (cdr (assoc ty types :test 'equal)) :void)))
      (multiple-value-bind (name ptrp) (pointer-passthrough p)
        (if ptrp
            (values :pointer (intern (string-upcase name)))
            (if (keywordp rt)
                (values rt (intern (string-upcase p)))
                (values (list :struct rt) (intern (string-upcase p)))))))))

#+nil(
      (convert-type '("SPAffineTransform3D" "*thing"))
      (convert-type '("SPAffineTransform3D" "thing"))
      (convert-type '("SPAffineTransform3D" nil))
      )

(defun simple-kebab-name (c-name)
  (ppcre:regex-replace-all "(SP|3D|Transform)" c-name "")
  ) ; TODO 2025-09-17 09:50:35

(defun lispify (parsed)
  (loop for (ret-type fn-name params) in parsed
          ;; TODO 2025-09-17 08:17:20 Is foreign-funcall-pointer any more direct/cacheable?
        collect
        `(defun ,(simple-kebab-name fn-name)
             ,(loop for p in params
                    collect (multiple-value-bind (ty pn) (convert-type p) pn))
           (cffi:foreign-funcall
            ,(format nil "wrap~a" fn-name)
            ,@(loop for p in params
                    nconc (multiple-value-list (convert-type p)))
            ,(convert-type (list ret-type nil))))))

#+nil(;; Output file for massaging and compilation.
      (with-open-file (o "wrap_spatial.m" :direction :output :if-exists :supersede)
        (wrap-fns (parse-file "spatial_fns.txt") o))

      ;; Check types
      (all-types (parse-file "spatial_fns.txt"))
      
      ;; Create ergonomic lisp fns
      (lispify (parse-file "spatial_fns.txt"))
      )
